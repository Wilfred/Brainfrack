Object subclass: #BFInterpreter	instanceVariableNames: 'cells cellIndex program programIndex input inputIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Brainfrack'!!BFInterpreter commentStamp: 'WilfredHughes 5/17/2016 01:29' prior: 0!I represent a Brainfuck (BF) intrepreter.I'm initialized with 10,000 cells (represented as bytes) all set to zero. I can execute any BF program.I write my output to Transcript.Example usage: BFIntepreter new    program: '+++++ +++++ +++++ +++++ +++++ +++++ +++ .';    execute.This writes !! to Transcript.!!BFInterpreter methodsFor: 'accessing' stamp: 'WilfredHughes 5/17/2016 00:42'!currentCell: anInteger	"Set the value of the cell currently at cellIndex"	cells at: cellIndex put: anInteger.! !!BFInterpreter methodsFor: 'accessing' stamp: 'WilfredHughes 5/15/2016 18:19'!cellIndex"Return the current cell index (1-indexed)."^ cellIndex! !!BFInterpreter methodsFor: 'accessing' stamp: 'WilfredHughes 5/15/2016 19:07'!currentCell	"Return the value of the cell currently at cellIndex"^ cells at: cellIndex 	! !!BFInterpreter methodsFor: 'executing' stamp: 'WilfredHughes 5/17/2016 01:16'!executeLeft	cellIndex < 1		ifTrue: [ self error: 'Tried to access cells before the first!!' ].	cellIndex := cellIndex - 1.	self advance.! !!BFInterpreter methodsFor: 'executing' stamp: 'WilfredHughes 5/17/2016 01:22'!executeLoopStart	| closeIndex |	self currentCell isZero		ifTrue: [ closeIndex := self class from: program findCloseOf: programIndex.			"skip over loop body."			programIndex := closeIndex + 1 ]		ifFalse: [ programIndex := programIndex + 1 ]		"execute the loop body"! !!BFInterpreter methodsFor: 'executing' stamp: 'WilfredHughes 5/17/2016 01:14'!advance"move on to the next program instruction"programIndex := programIndex + 1! !!BFInterpreter methodsFor: 'executing' stamp: 'WilfredHughes 5/17/2016 01:16'!executeRight	cellIndex := cellIndex + 1.	self advance.! !!BFInterpreter methodsFor: 'executing' stamp: 'WilfredHughes 5/17/2016 01:17'!executeRead	| inputChar |	inputIndex <= input size		ifTrue: [ inputChar := (input at: inputIndex) asInteger.			inputIndex := inputIndex + 1 ]		ifFalse: [ inputChar := 0 ].	self currentCell: inputChar.	self advance! !!BFInterpreter methodsFor: 'executing' stamp: 'WilfredHughes 5/17/2016 00:52'!program: aStringprogram := aString.! !!BFInterpreter methodsFor: 'executing' stamp: 'WilfredHughes 5/17/2016 01:16'!executeDecrement	self currentCell: (self currentCell - 1) \\ 256.	self advance! !!BFInterpreter methodsFor: 'executing' stamp: 'WilfredHughes 5/17/2016 01:17'!executeWrite	Transcript show: self currentCell asCharacter.	self advance! !!BFInterpreter methodsFor: 'executing' stamp: 'WilfredHughes 5/17/2016 01:22'!executeLoopEnd	| openIndex |					openIndex := self class from: program findOpenOf: programIndex.					programIndex := openIndex! !!BFInterpreter methodsFor: 'executing' stamp: 'WilfredHughes 5/17/2016 01:15'!executeIncrement	self currentCell: (self currentCell + 1) \\ 256.	self advance! !!BFInterpreter methodsFor: 'executing' stamp: 'WilfredHughes 5/17/2016 00:53'!input: aString	input := aString! !!BFInterpreter methodsFor: 'executing' stamp: 'WilfredHughes 5/16/2016 00:38'!instructionChars"Return a Set of the instruction characters in BF."^ Set newFrom: '+-<>[].,'! !!BFInterpreter methodsFor: 'executing' stamp: 'WilfredHughes 5/17/2016 01:23'!execute	"Execute a BF program, writing its output to Transcript"	[ programIndex <= program size ]		whileTrue: [ | char |			char := program at: programIndex.			"skip comments"			(self instructionChars includes: char)				ifFalse: [ self advance ].			char = $+				ifTrue: [ self executeIncrement ].			char = $-				ifTrue: [ self executeDecrement ].			char = $>				ifTrue: [ self executeRight ].			char = $<				ifTrue: [ self executeLeft ].			char = $[				ifTrue: [ self executeLoopStart ].			char = $]				ifTrue: [ self executeLoopEnd ].			char = $.				ifTrue: [ self executeWrite ].			char = $,				ifTrue: [ self executeRead ] ]! !!BFInterpreter methodsFor: 'initialization' stamp: 'WilfredHughes 5/17/2016 00:55'!initialize	cells := ByteArray new: 10000 withAll: 0.	cellIndex := 1.	program := ''.	programIndex := 1.	input := ''.	inputIndex := 1.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BFInterpreter class	instanceVariableNames: ''!!BFInterpreter class methodsFor: 'querying' stamp: 'WilfredHughes 5/15/2016 18:53'!from: aProgram findCloseOf: openIndex	"Given a BF program with a $[ at openIndex,	find the corresponding $], respecting nested brackets."	| depth |	openIndex > aProgram size		ifTrue: [ self errorSubscriptBounds: openIndex  ].	depth := 0.	"Iterate overall all chars after openIndex"	openIndex to: aProgram size do: [ :i | 		| char |		char := aProgram at: i.		"If the current char is an open, increase the depth"		char = $[			ifTrue: [ depth := depth + 1 ].		"if the current char is a close, decrease depth"		char = $]			ifTrue: [ depth := depth - 1.				"if depth is zer0, we've found the matching close"				depth = 0					ifTrue: [ ^ i ] ] ].	"If we reach this point, then we reached the end of the string"	"without finding a matching close"	self error: 'No matching ] found!!'! !!BFInterpreter class methodsFor: 'querying' stamp: 'WilfredHughes 5/15/2016 19:05'!from: aProgram findOpenOf: closeIndex	"Given a BF program with a $[ at closeIndex,	find the corresponding $], respecting nested brackets."	| depth |	(closeIndex > aProgram size or: closeIndex < 1)		ifTrue: [ self errorSubscriptBounds: closeIndex ].	depth := 0.	"Iterate on chars backwards from closeIndex"	closeIndex to: 1 by: -1 do: [ :i | 		| char |		char := aProgram at: i.		"If the current char is an open, increase the depth"		char = $[			ifTrue: [ depth := depth + 1.				"if depth is zero, we've found the matching open"				depth = 0					ifTrue: [ ^ i ] ].		"if the current char is a close, decrease depth"		char = $]			ifTrue: [ depth := depth - 1 ] ].	"If we reach this point, then we reached the start of the string"	"without finding a matching open"	self error: 'No matching [ found!!'! !!BFInterpreter class methodsFor: 'creation' stamp: 'WilfredHughes 5/17/2016 00:49'!withProgram: program andInput: inputString	"Instantiate a BFInterpreter with the program and input, for later execution. This is the recommended usage for this class."	|bi|	bi := self new.		! !!BFInterpreter class methodsFor: 'creation' stamp: 'WilfredHughes 5/17/2016 00:53'!program: program input: input	"Instantiate a BFInterpreter with the program and input, for later execution. This is the recommended usage for this class."	| bi |	bi := self new program: program; input: input; yourself! !TestCase subclass: #BFInterpreterTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Brainfrack-Tests'!!BFInterpreterTest commentStamp: '<historical>' prior: 0!A BFInterpreterTest is a test class for testing the behavior of BFInterpreter!!BFInterpreterTest methodsFor: 'tests-initialization' stamp: 'WilfredHughes 5/15/2016 19:09'!testInitialize	| bi |	bi := BFInterpreter new.	self assert: bi cellIndex equals: 1! !!BFInterpreterTest methodsFor: 'tests - queries' stamp: 'WilfredHughes 5/15/2016 19:05'!testFromFindOpenOf	| pos |	pos := BFInterpreter from: '[ [ ] ]' findOpenOf: 7.	self assert: pos equals: 1.	pos := BFInterpreter from: '[ [ ] ]' findOpenOf: 5.	self assert: pos equals: 3! !!BFInterpreterTest methodsFor: 'tests - queries' stamp: 'WilfredHughes 5/15/2016 18:49'!testFromFindCloseOf	| pos |	pos := BFInterpreter from: '[ [ ] ]' findCloseOf: 1.	self assert: pos equals: 7.	pos := BFInterpreter from: '[ [ ] ]' findCloseOf: 3.	self assert: pos equals: 5! !!BFInterpreterTest methodsFor: 'tests - queries' stamp: 'WilfredHughes 5/15/2016 18:57'!testFromFindCloseOfErrors	| errored |	errored := false.	[ BFInterpreter from: '[]' findCloseOf: 3 ] ifError: [ errored := true ].	self assert: errored.	errored := false.	[ BFInterpreter from: '[' findCloseOf: 1 ] ifError: [ errored := true ].	self assert: errored.! !!BFInterpreterTest methodsFor: 'tests-accessing' stamp: 'WilfredHughes 5/17/2016 00:43'!testCurrentCell	|bi|	bi := BFInterpreter new.	bi currentCell: 100.	self assert: bi currentCell equals: 100! !!BFInterpreterTest methodsFor: 'tests-accessing' stamp: 'WilfredHughes 5/15/2016 19:10'!testCellIndex|bi|bi := BFInterpreter new.self assert: bi currentCell equals: 0	! !!BFInterpreterTest methodsFor: 'tests-executing' stamp: 'WilfredHughes 5/15/2016 21:01'!testExecuteRight|bi|bi := BFInterpreter new.bi executeRight .self assert: bi cellIndex equals: 2.	! !!BFInterpreterTest methodsFor: 'tests-executing' stamp: 'WilfredHughes 5/15/2016 20:47'!testExecuteDecrement	| bi |	bi := BFInterpreter new.	bi executeDecrement.	self assert: bi currentCell equals: 255! !!BFInterpreterTest methodsFor: 'tests-executing' stamp: 'WilfredHughes 5/15/2016 21:04'!testExecuteLeft	| bi |	bi := BFInterpreter new.	bi executeRight; executeRight; executeLeft.	self assert: bi cellIndex equals: 2! !!BFInterpreterTest methodsFor: 'tests-executing' stamp: 'WilfredHughes 5/17/2016 01:27'!testExecute	| bi |	"basic increment and cell movement"	bi := BFInterpreter new		program: '>++-<+';		yourself.	self assert: bi execute currentCell equals: 1.	"falsy loop"	bi := BFInterpreter new		program: '[+]-';		yourself.	self assert: bi execute currentCell equals: 255.	"truthy loop"	bi := BFInterpreter new program: '+[-]'; yourself.	self assert: bi execute currentCell equals: 0.	"comments"	bi := BFInterpreter new program: ' + '; yourself.	self assert: bi execute currentCell equals: 1.	"input"	bi := BFInterpreter new                program: ',>,';		input: 'bc';		yourself.	self assert: bi execute currentCell equals: 99! !!BFInterpreterTest methodsFor: 'tests-executing' stamp: 'WilfredHughes 5/17/2016 01:05'!testExecuteRead	| bi |	bi := BFInterpreter new input: 'a'; yourself.	bi executeRead.	self assert: bi currentCell equals: 97.! !!BFInterpreterTest methodsFor: 'tests-executing' stamp: 'WilfredHughes 5/15/2016 20:55'!testExecuteIncrement	| bi |	"basic increment test"	bi := BFInterpreter new.	bi executeIncrement.	self assert: bi currentCell equals: 1.	"wrapping test"	bi := BFInterpreter new.	257 timesRepeat: [ bi executeIncrement . ].	self assert: bi currentCell equals: 1.! !